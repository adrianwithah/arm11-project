\documentclass[a4paper]{article}

\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}

\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\title{Group 11 Checkpoint Report}
\author{Halite Abudureyimu\\Yoram\\Justin\\Hadrian}
\begin{document}
\maketitle

\section{Group Work Allocation}
At the beginning of this project, the group was split into 2 subgroups:\\ \\
Halite Abudureyimu and Yoram Boccia co-worked on Part 1: the emulator. Halite designed the structure of the emulator, and coded the emulate.c, pipeline.c and emuexecute.c files. Yoram coded the emuio.c, emudecode.c, operation.c files. There was a really good communication between the two. Both of them debugged, cleaned and reorganized the files together.
\\\\
Meanwhile, Justin Chong and Hadrian Lim co-worked on the second part: the assembler. Justin outlined the structure of the assembler, implementing the logic behind parsing string tokens and arranging the bitcodes, whilst implementing a dynamic memory access structure to maintain minimal memory cost and reduce input-output overhead. Hadrian Lim implemented key utility utilities such as lookup functions and the symbol table struct. Debugging and testing was also done by Hadrian. Overall, the process was smooth and both members were in constant communication to ensure key functions were routinely ironed out and exchanged.
\\\\

While we were progressing with the project, we used gitlab to combine our works by pushing up the codes to our own branches, and the group leader was responsible of merging and maintaining the different codes accordingly.
We finished coding the emulator in 26-05-2018 and debugging it in 28-05-2018. We are now completing the assembler part. We plan to finish the third part and start to work on the fourth part before 02-06-2018.

\section{Opinions about Group Working}
\textbf{Halite:}\\
I think we are cooperating with each other really well. Yoram and I did the first part, during the working period, we talked to each other alot. Especially during the debugging, we operated the computer in turns in every two hours, which was really helpful for our efficiency since debugging is really overwhelming job.\\\\
In order to work together more effectively and delightfully, I assume that we can hang out together beyond the working time, like playing football, having dinners and watching movies. We can not know each other better by doing them, but also have some proper rest.\\
\\
\textbf{Yoram:}\\
I believe that our group is really motivated and we really communicated in an efficient way. We communicated right from the the beginning and split the work between us.
Halite and I worked really well on the emulator part. We planned the work together before starting coding out own part. We implemented functions that were needed by the other one and therefore we had to collaborate and communicate a lot.
Debugging was the best part because together we understood our final code and we wrote tests for every file before debugging the whole emulator. Together we managed to do it at the end.
For the next tasks I believe we should continue in the same way we are already doing, but maybe hanging out more together to rest a little bit from the project.
\\
\textbf{Justin:}\\
Our team were quick to decide on splitting the work, and Hadrian and I were tasked with tackling the assembler. Overall, I think we had good team synergy. Parts that I found confusing, such as the move command register shifting, and the rotates for immediate addressing, were only possible to tackle with the help of my teammates. I think we are quite productive as a team, thanks to our constant communication and structured work schedules.
\\\\
Overall, we might need to get ready to modularise the projects even more as we move to part 3 and 4. Part 3 and 4 cannot be done concurrently, and are projected to be much harder than the first two parts. Our initial system of splitting the first two parts into two separate teams was useful in spreading out the workload evenly, but with part 3 and 4 we would need to be more careful into making sure that we effectively allocate work to everyone in order to get the parts done as soon as possible and also move onto the extension. Overall, we would probably need to get to know each other a little more, to see where each individual is suited to do what tasks.\\
\\
\textbf{Hadrian:}\\
Communication within the group has been smooth so far. The group has been able to meet the deadlines that we agreed upon so far. Criticism towards each other's work has been constructive and well received. We can easily approach members of our team if we have any queries regarding the C language or to seek a second opinion on the spec. All in all, the team has a healthy dynamic that boosts productivity.
\\\\
For the future parts (III and IV), we will have to seperate the work initially, such that each of us do not depend on each other's code. This is crucial in the beginning. If we depend too much on each other's implementations, we might end up having to wait for each other and slow down individual development.

\section{Details About Emulator}
After reading the first part, we realized that there were several keywords that helped us to decompose the whole emulator, such as: $read and write$, $pipeline$, $alu$, $shifter$, $execute$, $decode$ and $fetch$. The spec helped us splitting the instructions into 4 main types. Thus, We use the keywords to structure the different files and the instructions types as switch to separate the different types. Then, Yoram and Halite discussed and confirmed over the details about the precoditions and postconditions of their own parts as following:
\\\\
\textbf{emulate.c:} the main functions is pretty straightforward: allocate memory to state, read binary, simulate the pipeline, and write out the result. So it calls $new\_state$ and $delete\_state$ in \textbf{emustruct.c}, $emuread$ and $emuwrite$ f in \textbf{emuio.c}, and $pipeline\_circle$ functions in \textbf{pipeline.c}.
\\\\
\textbf{emuio.c:} contains 2 major functions: $emuread$ and $emuwrite$. \textbf{emuread} read the binary file and convert the binary numbers into decimal form and save it into our "memory".
\textbf{emuwrite:} outputs the result of "registers" and "non-zero memory address".
\\\\
\textbf{pipeline.c} contains 4 major functions: $pipeline\_circle$, $execute$, $decode$, and $fetch$. The $pipeline\_circle$ uses the other 3 functions to simulate the process. $fetch$ get the instruction code from the "memory". $decode$ decomposes the fetched code into small parts according to 4 major instruction types by calling them in \textbf{emudecode.c}. Finally, $execute$ function passes the instruction and storage into 4 major instruction type execution coded in \textbf{emuexecute.c} .
\\\\
\textbf{emudecode.c} contains 4 major functions according to 4 different instruction types.
\\\\
\textbf{emuexecute.c} contains 4 major functions according to 4 different instruction types. And specifically, the $execute\_data\_processing$ function implements the instruction by putting elements into \textbf{alu} and \textbf{shifter}, which are combined in \textbf{operation.c}\\
\\\\
\textbf{operation.c:} contains all the operations coming from the alu and the shifter.
\\\\
\textbf{emudef.h:} contains all the definitions of constant number and enum types in our emulator project.
\\\\
\textbf{emustruct.h:} contains all the struct types we used in the project, such as State, Storage and Instructions, and the declaration of $new\_state$ and $delete\_state$ functions.
\\\\
\textbf{emustruct.h} contains the above two functions. $new\_state$ allocates memory space to our spaces, including the elements in the state. $delete\_state$ frees all the memory space allocated in $new\_state$.

\section{Usefull Skills for the Assembeler}
Generally, knowledge in how the binary instructions will be decoded in the emulator helps in understanding the encoding for assembly instructions. As such, members working on the emulator could help provide valuable feedback on any misunderstandings regarding the assembler.
\\\\
Specifically in terms of implementation details, there are a few functions used in the emulator that we have found useful for the assembler. These are general functions that deal with bits manipulation. Examples of such functions include a function to logical shift right and a function to extract certain bits from a binary representation.

\section{A discussion on implementation tasks that you think you will find difficult / challenging later on,
and how you are working to mitigate these}
We think it will be challenging to implement the extensions for this project because we just have one Raspberry Pi and we are four in the group. Nevertheless we are going to meet every time in order to mitigate these circumstances and in order to make everyone use the Raspberry Pi.
\\\\
Of course another difficulty is going to be the small amount of time we have for this project, and therefore we have to implement extensions that are doable before the deadline. Hence, we are going to plan first every detail of our extension and consider if it is possible to finish it before the time and then we will split the work between the four of us.

\end{document}
