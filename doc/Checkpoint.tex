\documentclass[a4paper]{article}

\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}

\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\title{Group 11 Checkpoint Report}
\author{Halite Abudureyimu\\Yoram\\Justin\\Hadrian}
\begin{document}
\maketitle

\section{Group Work Allocation}
At the beginning in this project, 4 of us splited into 2 groups:\\ \\
Halite Abudureyimu and Yoram ... co-work the first part: emulator. Halite designed the structure of the emulator, and coded the emulate.c,pipeline.c emuexecute.c files. Yoram coded the emuio.c emudecode.c operation.c files. Both of them debuged, cleaned and reorganized the files together.
\\\\
Justin ... and Hadrian co-work the second part: assembler. /*need details*/
\\\\

While we were coding, we use git lab to combine our works by pushing up the codes to our own branches, and the group leader merge and maintain the codes accordingly. We finished coding the emulator in 26-05-2018 and debugging in 28-05-2018. And we are going to finish the assembler in 31-05-2018. Also, before 02-06-2018, we will finish the third part and start to work with the fourth part.

\section{Opinions about Group Working}
\textbf{Halite:}\\
I think we are cooperating with each other really well. Yoram and I did the first part, during the working period, we talked to each other alot. Especially during the debugging, we operated the computer in turns in every two hours, which was really helpful for our efficiency since debugging is really overwhelming job.\\\\
In order to work together more effectively and delightfully, I assume that we can hang out together beyond the working time, like playing football, havind dinners and watching movies. We can not know each other better by doing them, but also have some proper rest.\\
\\
\textbf{Yoram:}\\
 how well you think the group is working
\\\\
how you imagine it might need to change for the later tasks.\\
\\
\textbf{Justin:}\\
 how well you think the group is working
\\\\
how you imagine it might need to change for the later tasks.\\
\\
\textbf{Hadrian:}\\
 how well you think the group is working
\\\\
text
how you imagine it might need to change for the later tasks.

\section{Details About Emulator}
After reading the first part, we realized that there were several key noun words that help us decompose the whole emulator, such as: $read and write$, $pipeline$, $alu$, $shifter$, $execute$, $decode$, $fetch$. And the spec already helped us split the instructions into 4 main types. Thus, We use the key words to structure the files and the instructions types as switch to seperate the different types. Then, Yoram and Halite discussed and confirmed over the details about the precoditions and postconditions of their own parts as following:
\\\\
\textbf{emulate.c:} the main functions is pretty straitforward: allocate memory to state, read binary, simulate the pipeline, and write out the result. So it calls $new_state$ and $delete_state$ in \textbf{emustruct.c}, $emuread$ and $emuwrite$ f in \textbf{emuio.c}, and $pipeline_circle$ functions in \textbf{pipeline.c}.\\
\\\\
\textbf{emuio.c:} contains 2 major functions: $emuread$ and $emuwrite$. \textbf{emuread} read the binary file and convert the binary numbers into decimal form and save it into our "memory".
\textbf{emuwrite:} out put the result of "registers" and "memory address".
\\\\
\textbf{pipeline.c} contains 4 major functions: $pipeline_circle$, $execute$, $decode$, and $fetch$. The $pipeline_circle$ uses the other 3 functions to simulate the process. $fetch$ get the instruction code from the "memory". $decode$ decomposes the fetched code into small parts according to 4 major instruction types by calling them in \textbf{emudecode.c}. Finally, $execute$ function passes the instruction and storage into 4 major instruction type execution coded in \textbf{emuexecute.c} .
\\\\
\textbf{emudecode.c} contains 4 major functions according to 4 different instruction types.
\\\\
\textbf{emuexecute.c} contains 4 major functions according to 4 different instruction types. And specifically, the $execute_data_processing$ function implements the instruction by putting elements into \textbf{alu} and \textbf{shifter}, which are combined in \textbf{operation.c}\\
\\\\
\textbf{operation.c:} please read above.
\\\\
\textbf{emudef.h:} contains all the definations of constant number, enum types in our emulator project.
\\\\
\textbf{emustruct.h:} contains all the struct types we used in the project, such as State, Storage and Instructions, and the declaration of $new_state$ and $delete_state$ functions.
\\\\
\textbf{emustruct.h} contains the above two functins. $new_state$ allocates memory space to our spaces, including the elements in the state. $delete_state$ frees all the memory space allocated in $new_state$.
\\\\


\section{Usefull Skills for the Assembeler}

\section{A discussion on implementation tasks that you think you will find difficult / challenging later on,
and how you are working to mitigate these}

\end{document}