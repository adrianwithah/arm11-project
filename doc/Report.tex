%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Imperial Placement Report Template 
% LaTeX Template
% Version 1.0 (28/06/16)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	%%%%%%%%%
%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[a4paper]{article}
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[toc,page]{appendix}
\usepackage[T1]{fontenc}
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

\begin{document}

\begin{titlepage}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here
\setlength{\topmargin}{0in}
\center % Center everything on the page
 
 
 \begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
\hspace*{-0.5cm}
\end{flushleft}
\end{minipage}
~
\begin{minipage}{0.5\textwidth}
\begin{flushright} \large
\hspace*{2cm}
% \includegraphics[scale=0.4]{company.png}\\
\end{flushright}
\end{minipage}\\[1cm]
%----------------------------------------------------------------------------------------
%	HEADING SECTIONS
%----------------------------------------------------------------------------------------

\textsc{\LARGE Imperial College of Science, Technology and Medicine}\\[1.5cm] % Name of your university/college
\textsc{\Large Department of Computing}\\[0.5cm] % Major heading such as course name

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\HRule \\[0.4cm]
{ \huge \bfseries BeatIt}\\[0.4cm] % Title of your document
\HRule \\[1cm]
 
%----------------------------------------------------------------------------------------
%	AUTHOR SECTION
%----------------------------------------------------------------------------------------

\textsc{{\large
\textbf{Group 11} \\
Yoram \textsc{Boccia}, \\
Justin \textsc{Chong}, \\ 
Halite \textsc{Abudureyimu}, \\
Hadrian \textsc{Lim} }}\\[0.5cm]

%----------------------------------------------------------------------------------------
%	DATE SECTION
%----------------------------------------------------------------------------------------

{\large \today}\\[0.5cm] % Date, change the \today to a set date if you want to be precise


\vfill % Fill the rest of the page with whitespace

\end{titlepage}

\newpage



\section{Details About Assembler}
The Assembler can be split into to main loops, the first pass, and the second. In the first pass, the assembler builds the symbol table to be used for branching, and also initializes several parameters to be used in the second pass such as the number of instructions, etc. The second pass goes through and dynamically parses each instruction, and uses conditional branching to split the flow of logic to it's respective ARM instruction subset ($Data\ Processing$, $Multiply$, $Single\ Data\ Transfers$, and $Branching$).
\\\\
The data structures used throughout the assembler are as follows: The symbol table is stored as an array of $symbol$ structs, each containing the label, and it's corresponding line number. The instruction binary data is stored as an array of unsigned 32 bit integers.
\\\\
\textbf{assemble.c:} Entry point of the assembler, which defines the logic for the first and second passes. It handles line by line file IO and passes it into the first pass and second pass functions. The function then calls the $parseString$ function from \textbf{parseStr.c}, and passes the return value from the parser to be encoded by \textbf{assencode.c}. It stores the resulting binary output into the $uint32\_t$ array, and writes it to the output file after parsing all instructions.
\\\\
\textbf{parseStr.c:} Identifies the assembly instruction via character matching of the input string. It then calls the corresponding function from \textbf{parseData.c} whilst passing in relevant parameters based on the input string (such as opcode).
\\\\
\textbf{parseData.c:} Takes in parameters and wraps it in the instruction struct, to be encoded into binary by \textbf{assencode.c}.
\\\\
\textbf{assencode.c:} HADRIAN LIM.
\\\\
\textbf{strutils.c:} Contains several helper functions that helps string parsing. 

\section{Details about the Extension}
We decided to design a game. In this game there is a character, Michael Jackson, whose aim is to defeat every enemy who come from right or left. The user control the game through five buttons. The right button makes the character to punch and kick the enemy coming from the right and the left button makes the same on the left. We implemented a graphic interface for the game and the character has a fixed amount of lives before game over. 
\\\\
An example of the game is: \\\\
% insert Demo of the game!!!!
\textbf{Controller}\\\\
\textbf{1.Abstract:}  Yoram and Halite did the controller part of our extension. In this part, we enabled Raspberry Pi to an bluetooth joystick emulator, so that if we pressed the bottoms on our “Joystick”, we can control the action of our main character in our BEATIT game. For this part we follow the “Emulate a Bluetooth keyboard with the Raspberry Pi” tutorial and make some changes to it. 
For the programming part, we choose python language to code our program, since there are plenty of libraries we can use to build our controller in a really limited time. None of use have learned Python before, so we spent three days to learn the python’s syntax and useful functions.
\\\\
\textbf{2.Hardware:}\\
1) A Raspberry Pi with all necessary peripherals   \\\\
2) A USB Bluetooth dongle \\\\
3) A USB hub – if you want to use a keyboard and mouse at the same time as the Bluetooth dongle  \\\\
4) 5 button switch (emulate A, S, W, E, Q riespectively).  \\\\
\textbf{3.Files:} \\\\
\textbf{1) kbclient.py :}\\
a) connection between Pi and PC. We use bluetooth dongle as a connection device and D-Bus as the communication interface by using SDP(Service Discovery Protocal)
\\\\
b) get input from pi: We import RPi.GPIO library to setup and read our inputs. And use keymap.py file to convert our input into codes which is compatible to the D-BUS SDP fromat.
\\\\
c) sending input:	this part is simple, after getting the correct sending format, simple use cinterrupt.send(str) to send our input to the server, and our pc would get the signal from it.
\\\\
\textbf{2) keymap.py:} This file contains a dictionary mapping evdev keys to Bluetooth keys \\
sendingstring.py and btkserver.py: we use the authors code, the details is in the references.
\\\\
\textbf{4.Testing:} After coding, we tried to connect our pi to different devices: Linux, Windows, Mac PCs and Android and IOS phones. The connection overall is stable and suitable for the above devices. The effect of pressing the buttons are stable, correct and instance.
\\\\
\textbf{5.Definations:} \\\\
\textbf{1) D-Bus:} it is a framework used commonly on Linux that allows communication and remote procedure calls (calling a function in a different program) between different processes. \\\\
\textbf{2) SDP:} The Session Description Protocol (SDP) is a format for describing streaming media communications parameters. 
\\\\
\textbf{6.Reference:}\\
https://www.gadgetdaily.xyz/emulate-a-bluetooth-keyboard-with-the-raspberry-pi/\\
http://mlabviet2016.blogspot.com/2017/09/make-raspberry-pi3-as-emulator.html\\
https://en.wikipedia.or/wiki/Session\_Description\_Protocol\\
https://impythonist.wordpress.com/2014/02/01/emulate-a-bluetooth-keyboard-with-the-raspberry-pi/\\


\section{Design and Challenges/Problems}
\textbf{rendering:} It was difficult to find an appropriate graphics library that could be light weight, support a multitude of platforms, whilst using the standard libraries (as we decided not to use libraries that aren't installed in lab machines). Eventually we managed to find and slightly modify an libX11 wrapper, that was very lightweight and supported simple input output detection. The bare bone nature of the library made it inefficient, which eventually led to the slowdown of the application on Lab computers, requiring us to optimize the rendering process. 
\\\\
\textbf{audio:} It was near impossible to find a C audio library that could handle cross platform file parsing and audio playback. We eventually decided to rely on the built in SDL2.
% TODO

\section{Testing the Extension}
We split the work into two parts and we have tested both of them. //need details
\\\\


\section{Group reflection}
We worked really well together. From the beginning we communicated a lot. We understood the strengths of each member of the group and, accordingly, we split the different tasks throughout the implementation of the project. We started splitting the work since the beginning with the emulator and we found it very useful. Every while, we would meet all together to explain the progresses and to plan the next tasks. We used a lot git, where each of us worked on a different branch and then merge all the different parts together. 
\\\\
We believe that we communicated in a very efficient way and that the way we split the work was very helpful. Every time we had to implement another task, we would first analyze everything and build all together the structure of the project. Only when we were all sure to understand what was going on and that what we wanted to make was doable in the available time, only then we would start actually coding. We think that this tactics really helped us a lot and we always finished the different tasks before the deadlines we planned for ourselves. Moreover, we also organized football matches and dinner together to create a friendly atmosphere in the group and this helped a lot because we dealt with each part of the project with enthusiasm and every time one of us had problems, we would work together to solve them.

\section{Individual reflection}
\textbf{Halite:}\\
I personlly believe that this project is one of the greatest experience in my life. Because during this period, I learned lots of communication skills, programming cooperation techniques, as well as usefull project developing knowledge. For example, I learned how to use git lab/hub efficiently with my teammates. Also, I learned how the network connection works and what is D-Bus, SDP. Furthurmore, I acquired some electrical components and curcuits knowledge.\\\\
Speaking of our team, I think we did a really great job. None of us had the experience of group project before, but we did it, we managed to develop a game and blutooth joystick in really limited time. I think for a buch of beginners it is not easy. All of the members worked so hard, learned lots of new knowledge, and made a really great contribution to the project. Thanks for the department give us this opportunity and thanks for my teammates.
\\
\\
\textbf{Yoram:}\\
I believe that we really worked proficiently together. I fitted in the group very well. I was really glad to see my WebPA feedbacks. I have never programmed in C before, as other members of my group, but all together we helped each other and we put a lot of effort in learning and in solving the different parts of the project. At the beginning I was a little bit scared because I did not know this programming language, but I was not the only one and I just had to work maybe harder at the beginning to learn it. Some of my strengths that I think really helped the group are the creativity, the fact that I want to have a clean and structured code, and the will to test every single function to be sure that everything works as we want.
I would not change anything we did as a group because we had an efficient communication and we have split the work in a proficient way. With different people I would create again the same friendly environment in order to work well together. I would analyze the tasks before starting to implement them, I would plan some deadlines to respect and I would continue to use Git to split the work and then merge it. 
\\\\
\textbf{Justin:}\\
Our team were quick to decide on splitting the work, and Hadrian and I were tasked with tackling the assembler. Overall, I think we had good team synergy. Parts that I found confusing, such as the move command register shifting, and the rotates for immediate addressing, were only possible to tackle with the help of my teammates. I think we are quite productive as a team, thanks to our constant communication and structured work schedules. Overall, we might need to get ready to modularise the projects even more as we move to part 3 and 4. Part 3 and 4 cannot be done concurrently, and are projected to be much harder than the first two parts. Overall, we would probably need to get to know each other a little more, to see where each individual is suited to do what tasks.\\
\\
\textbf{Hadrian:}\\
Communication within the group has been smooth so far. The group has been able to meet the deadlines that we agreed upon so far. Criticism towards each other's work has been constructive and well received. We can easily approach members of our team if we have any queries regarding the C language. All in all, the team has a healthy dynamic that boosts productivity. For the future parts (III and IV), we will have to seperate the work initially, such that each of us do not depend on each other's code. If we depend too much on each other's implementations, we might end up having to wait for each other and slow down individual development.


\end{document}
